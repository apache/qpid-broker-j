/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY

 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

// ----------------------------------------------------------------------------
// OPTIONS
// ----------------------------------------------------------------------------
options {

  STATIC = false;

  UNICODE_INPUT = true;

  ERROR_REPORTING = true;
}

// ----------------------------------------------------------------------------
// PARSER
// ----------------------------------------------------------------------------

PARSER_BEGIN(ExpressionParser)
/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

package org.apache.qpid.server.query.engine.parsing;

import java.io.StringReader;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import org.apache.qpid.server.query.engine.exception.Errors;
import org.apache.qpid.server.query.engine.exception.QueryParsingException;
import org.apache.qpid.server.query.engine.parsing.query.Order;
import org.apache.qpid.server.query.engine.parsing.query.OrderItem;
import org.apache.qpid.server.query.engine.parsing.query.QueryExpression;
import org.apache.qpid.server.query.engine.parsing.query.SelectExpression;
import org.apache.qpid.server.query.engine.parsing.query.WithItem;
import org.apache.qpid.server.query.engine.parsing.expression.Expression;
import org.apache.qpid.server.query.engine.parsing.expression.ExpressionNode;
import org.apache.qpid.server.query.engine.parsing.expression.literal.ConstantExpression;
import org.apache.qpid.server.query.engine.parsing.expression.set.SetExpression;
import org.apache.qpid.server.query.engine.parsing.factory.AccessorExpressionFactory;
import org.apache.qpid.server.query.engine.parsing.factory.ArithmeticExpressionFactory;
import org.apache.qpid.server.query.engine.parsing.factory.ComparisonExpressionFactory;
import org.apache.qpid.server.query.engine.parsing.factory.ConditionalExpressionFactory;
import org.apache.qpid.server.query.engine.parsing.factory.LiteralExpressionFactory;
import org.apache.qpid.server.query.engine.parsing.factory.LogicExpressionFactory;
import org.apache.qpid.server.query.engine.parsing.factory.FunctionExpressionFactory;
import org.apache.qpid.server.query.engine.parsing.factory.ProjectionExpressionFactory;
import org.apache.qpid.server.query.engine.parsing.factory.SetExpressionFactory;
import org.apache.qpid.server.query.engine.parsing.factory.UnaryExpressionFactory;
import org.apache.qpid.server.query.engine.validation.SelectExpressionValidator;

/**
 * Simplified SQL parser generated by JavaCC
 *
 * Do not edit this .java file directly - it is autogenerated from ExpressionParser.jj
 */
@SuppressWarnings("all")
public class ExpressionParser<T, R>
{

    private final SelectExpressionValidator _selectExpressionValidator = new SelectExpressionValidator();

    public ExpressionParser()
    {
        this(new StringReader(""));
    }

    public QueryExpression<T, R> parseQuery(String sql) throws ParseException
    {
        this.ReInit(new StringReader(sql));
        return query();
    }

    public Expression<T, R> parseExpression(String sql) throws ParseException
    {
        this.ReInit(new StringReader(sql));
        return addExpression();
    }

    public String decode(String source)
    {
        final StringBuilder stringBuilder = new StringBuilder();
        for(int i = 1; i < source.length() - 1; i++ )
        {
            char c = source.charAt(i);
            if( c == '"' || c == 0x27)
            {
                i++;
            }
            stringBuilder.append(c);
        }
        return stringBuilder.toString();
    }
}

PARSER_END(ExpressionParser)

// ----------------------------------------------------------------------------
// Tokens
// ----------------------------------------------------------------------------

/* White Space */
<*> SKIP: {
  < " " | "\t" | "\r" | "\n" | "\r\n" | "\f" >
}

/* Comments */
SKIP:
{
  <LINE_COMMENT: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}

SKIP:
{
  <BLOCK_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

/* Reserved Words */
TOKEN [IGNORE_CASE] :
{
    <  ALL          : "ALL">
  | <  AND          : "AND">
  | <  AS           : "AS">
  | <  ASC          : "ASC">
  | <  BETWEEN      : "BETWEEN">
  | <  CASE         : "CASE">
  | <  DAY          : "DAY">
  | <  DESC         : "DESC">
  | <  DISTINCT     : "DISTINCT">
  | <  ELSE         : "ELSE">
  | <  END          : "END">
  | <  ESCAPE       : "ESCAPE">
  | <  EXCEPT       : "EXCEPT">
  | <  FALSE        : "FALSE" >
  | <  FROM         : "FROM">
  | <  GROUP_BY     : "GROUP BY">
  | <  HAVING       : "HAVING">
  | <  HOUR         : "HOUR">
  | <  IN           : "IN">
  | <  INTERSECT    : "INTERSECT">
  | <  IS           : "IS">
  | <  JOIN         : "JOIN">
  | <  LIKE         : "LIKE">
  | <  LIMIT        : "LIMIT">
  | <  MILLISECOND  : "MILLISECOND">
  | <  MINUS        : "MINUS">
  | <  MINUTE       : "MINUTE">
  | <  MONTH        : "MONTH">
  | <  NOT          : "NOT">
  | <  NULL         : "NULL" >
  | <  OFFSET       : "OFFSET">
  | <  ON           : "ON">
  | <  OR           : "OR">
  | <  ORDER_BY     : "ORDER BY">
  | <  SECOND       : "SECOND">
  | <  SELECT       : "SELECT">
  | <  THEN         : "THEN">
  | <  TRUE         : "TRUE" >
  | <  UNION        : "UNION">
  | <  WHEN         : "WHEN">
  | <  WHERE        : "WHERE">
  | <  WEEK         : "WEEK">
  | <  WITH         : "WITH">
  | <  YEAR         : "YEAR">
}

/* Functions */
TOKEN [IGNORE_CASE] :
{
      <  ABS                : "ABS">
    | <  AVG                : "AVG">
    | <  COALESCE           : "COALESCE">
    | <  CONCAT             : "CONCAT">
    | <  COUNT              : "COUNT">
    | <  CURRENT_TIMESTAMP  : "CURRENT_TIMESTAMP">
    | <  DATE               : "DATE">
    | <  DATEADD            : "DATEADD">
    | <  DATEDIFF           : "DATEDIFF">
    | <  EXTRACT            : "EXTRACT">
    | <  LEN                : "LEN">
    | <  LENGTH             : "LENGTH">
    | <  LOWER              : "LOWER">
    | <  LTRIM              : "LTRIM">
    | <  MAX                : "MAX">
    | <  MIN                : "MIN">
    | <  POSITION           : "POSITION">
    | <  REPLACE            : "REPLACE">
    | <  ROUND              : "ROUND">
    | <  RTRIM              : "RTRIM">
    | <  SUBSTR             : "SUBSTR">
    | <  SUBSTRING          : "SUBSTRING">
    | <  SUM                : "SUM">
    | <  TRIM               : "TRIM">
    | <  TRUNC              : "TRUNC">
    | <  UPPER              : "UPPER">
}

/* Operators */
TOKEN :
{
   < ASTERIX        : "*">
 | < COMMA          : "," >
 | < LBRACKET       : "(" >
 | < NOT_EQUAL      : ("!=" | "<>") >
 | < RBRACKET       : ")" >
 | < POINT          : "." >
}

/* Literals */
TOKEN [IGNORE_CASE] :
{
    < DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* (["l","L"])? >
  | < HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
  | < OCTAL_LITERAL: "0" (["0"-"7"])* >
  | < FLOATING_POINT_LITERAL:
          (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? // matches: 5.5 or 5. or 5.5E10 or 5.E10
        | "." (["0"-"9"])+ (<EXPONENT>)?              // matches: .5 or .5E10
        | (["0"-"9"])+ <EXPONENT>                     // matches: 5E10
    >
  | < #EXPONENT: "E" (["+","-"])? (["0"-"9"])+ >
  | < STRING_LITERAL: "'" ( ("''") | ~["'"] )*  "'" >
  | < FUNCTIONNAME : (
        <ABS> | <AVG> | <COALESCE> | <CONCAT> | <COUNT> | <CURRENT_TIMESTAMP>  | <DATE> | <LEN> | <LENGTH> | <LOWER>
        | <LTRIM> | <MAX> | <MIN> | <REPLACE> | <ROUND> | <RTRIM> | <SUBSTR> | <SUBSTRING> | <SUM> | <TRIM>
        | <TRUNC> | <UPPER>
    ) <LBRACKET> >
}

TOKEN [IGNORE_CASE] :
{
    < ID : ["a"-"z", "_", "$"] (["a"-"z","0"-"9","_", "$"])* >
    | < QUOTED_ID : "\"" ( ("\"\"") | ~["\""] )*  "\""  >
}

// ----------------------------------------------------------------------------
// Grammar
// ----------------------------------------------------------------------------

QueryExpression<T, R> query() :
{
    QueryExpression<T, R> query = new QueryExpression<>();
    WithItem<T, R> withItem;
    List<WithItem<T, R>> withItems = new ArrayList<>();
    boolean distinct = true;
    SetExpression<T, R> left;
    SetExpression<T, R> right;
    OrderItem<T, R> orderItem;
}
{
    <WITH> withItem = withItem() { withItems.add(withItem); } (<COMMA> withItem() { withItems.add(withItem); } )*
    query = query()
    {
        query.setWithItems(withItems);
        return query;
    }
    |
    ( <LBRACKET> left = select() <RBRACKET> | left = select() )
    (
        <UNION> [ <ALL> { distinct = false; } | <DISTINCT> { distinct = true; } ]
        ( LOOKAHEAD(3) <LBRACKET> right = select() <RBRACKET> | right = select() )
        { left = (SetExpression<T, R>) SetExpressionFactory.union(distinct, (SetExpression<T, Stream<Map<String, Object>>>) left, (SetExpression<T, Stream<Map<String, Object>>>)right); }
        |
        (<EXCEPT> | <MINUS>) [ <ALL> { distinct = false; } | <DISTINCT> { distinct = true; } ]
        ( LOOKAHEAD(3) <LBRACKET> right = select() <RBRACKET> | right = select() )
        { left = (SetExpression<T, R>) SetExpressionFactory.minus(distinct, (SetExpression<T, Stream<Map<String, Object>>>) left, (SetExpression<T, Stream<Map<String, Object>>>)right); }
        |
        <INTERSECT> [ <ALL> { distinct = false; } | <DISTINCT> { distinct = true; } ]
        ( LOOKAHEAD(3) <LBRACKET> right = select() <RBRACKET> | right = select() )
        { left = (SetExpression<T, R>) SetExpressionFactory.intersect(distinct, (SetExpression<T, Stream<Map<String, Object>>>) left, (SetExpression<T, Stream<Map<String, Object>>>)right); }
    )*
    {
        query.setSelect(left);
    }
    ( <ORDER_BY> orderItem = orderItem() { query.addOrderItem(orderItem); } (<COMMA> orderItem = orderItem() { query.addOrderItem(orderItem); } )* )?
    [ <LIMIT> <DECIMAL_LITERAL> { query.setLimit((Integer)LiteralExpressionFactory.fromDecimal(token.image).apply(null)); } ]
    [ <OFFSET> (<DECIMAL_LITERAL> { query.setOffset((Integer)LiteralExpressionFactory.fromDecimal(token.image).apply(null)); }
        | <OCTAL_LITERAL> { query.setOffset((Integer)LiteralExpressionFactory.fromOctal(token.image).apply(null)); }) ]
    {
        return query;
    }
}

WithItem withItem():
{
    WithItem<T, R> withItem;
    String name;
    String alias;
    List<String> aliases = new ArrayList<>();
    QueryExpression<T, R> query;
}
{
    name = identifier() (<LBRACKET> alias = identifier() { aliases.add(alias); }
    ( <COMMA> alias = identifier() { aliases.add(alias); } )* <RBRACKET>)? <AS> <LBRACKET> query = query() <RBRACKET>
    {
        return new WithItem<>(name, aliases, query);
    }
}

OrderItem<T, R> orderItem() :
{
    Order order = Order.ASC;
    ExpressionNode<T,R> expression;
}
{
    expression = orExpression() [ <ASC> | <DESC> { order = Order.DESC; } ]
    {
        return new OrderItem<>(expression.getAlias(), expression, order);
    }
}

SelectExpression<T, R> select() :
{
    SelectExpression<T, R> select = new SelectExpression<>();
    ExpressionNode<T, R> item;
    String domain;
    String alias = null;
    ExpressionNode<T, R> where;
    ExpressionNode<T, R> having;
    ExpressionNode<T, R> groupByItem;
}
{
    <SELECT> ( <ALL> | <DISTINCT> { select.distinct(true); } )?  ( LOOKAHEAD(2) <ASTERIX> projectItems(select) | projectItem(select) (<COMMA> projectItem(select) )* )
    ( <FROM> domain = identifier() ( [ <AS> ] alias = identifier() )? { select.from(domain, alias); }
        ( <COMMA> domain = identifier() ( [ <AS> ] alias = identifier() )? { select.from(domain, alias); }
        |
        <JOIN> domain = identifier() { select.join(); } ( [ <AS> ] alias = identifier() )? )*
    )?
    ( <WHERE> where = predicate() { select.where(where); } )?
    ( <GROUP_BY> { select.resetOrdinal(); } groupByItem = groupItem(select) (<COMMA> groupByItem = groupItem(select) )* )?
    ( <HAVING> having = predicate() { select.having(having); } )?
    {
        _selectExpressionValidator.validate(select);
        return select;
    }
}

void projectItems(SelectExpression select) :
{
}
{
    {
        select.selectAll();
    }
}

void projectItem(SelectExpression<T, R> select) :
{
    String alias = null;
    ExpressionNode<T, R> expr;
}
{
    ( LOOKAHEAD(2) expr = orExpression() | LOOKAHEAD(2) <LBRACKET> expr = select() <RBRACKET> ) ( ( [ <AS> ] | " " ) alias = identifier() )?
    {
        select.selectItem(ProjectionExpressionFactory.projection(expr, alias, select.getOrdinal()));
    }
}

ExpressionNode<T, R> groupItem(SelectExpression select) :
{
    ExpressionNode<T, R> expr;
    String alias;
}
{
    expr = orExpression()
    {
        select.groupBy(ProjectionExpressionFactory.projection(expr, expr.getAlias(), select.getOrdinal()));
        return expr;
    }
}

ExpressionNode<T, R> predicate() :
{
    ExpressionNode<T, R> left;
}
{
    left = orExpression()
    {
        return left;
    }

}

ExpressionNode<T, R> orExpression() :
{
    ExpressionNode<T, R> left;
    ExpressionNode<T, R> right;
    StringBuilder stringBuilder = new StringBuilder();
}
{
    left = andExpression()
    (
        <OR> { stringBuilder.append(left.getAlias()).append(" or "); } right = andExpression()
        {
            stringBuilder.append(right.getAlias());
            left = (ExpressionNode<T, R>) LogicExpressionFactory.or(stringBuilder.toString(), left, right);
        }
    )*
    {
        return left;
    }

}

ExpressionNode<T, R> andExpression() :
{
    ExpressionNode<T, R> left;
    ExpressionNode<T, R> right;
    StringBuilder stringBuilder = new StringBuilder();
}
{
    left = equalityExpression()
    (
        <AND> { stringBuilder.append(left.getAlias()).append(" and "); } right = equalityExpression()
        {
            stringBuilder.append(right.getAlias());
            left = (ExpressionNode<T, R>) LogicExpressionFactory.and(stringBuilder.toString(), left, right);
        }
    )*
    {
        return left;
    }
}

ExpressionNode<T, R> equalityExpression() :
{
    ExpressionNode<T, R> left;
    ExpressionNode<T, R> right;
}
{
    left = comparisonExpression()
    (
        "=" right = comparisonExpression()
        {
    left = (ExpressionNode<T, R>) LogicExpressionFactory.toFunction(ComparisonExpressionFactory.equalExpression(left, right));
}
        |
        <NOT_EQUAL> right = comparisonExpression()
        {
    left = (ExpressionNode<T, R>) LogicExpressionFactory.toFunction(ComparisonExpressionFactory.notEqualExpression(left, right));
}
        |
        LOOKAHEAD(2)
        <IS> <NULL>
        {
    left = (ExpressionNode<T, R>) LogicExpressionFactory.toFunction(ComparisonExpressionFactory.isNullExpression(left));
}
        |
        <IS> <NOT> <NULL>
        {
    left = (ExpressionNode<T, R>) LogicExpressionFactory.toFunction(ComparisonExpressionFactory.isNotNullExpression(left));
}
    )*
    {
        return left;
    }
}

ExpressionNode<T, R> comparisonExpression() :
{
    ExpressionNode<T, R> left;
    ExpressionNode<T, R> right;
    ExpressionNode<T, R> low;
    ExpressionNode<T, R> high;
    String t, u;
	boolean not;
	ArrayList<ExpressionNode<T, R>> list;
    StringBuilder stringBuilder = new StringBuilder();
}
{
    left = addExpression() { stringBuilder.append(left.getAlias()); }
    (
        ">" right = addExpression()
        {
    left = (ExpressionNode<T, R>) LogicExpressionFactory.toFunction(ComparisonExpressionFactory.greaterThanExpression(left, right));
}
        |
        ">=" right = addExpression()
        {
    left = (ExpressionNode<T, R>) LogicExpressionFactory.toFunction(ComparisonExpressionFactory.greaterThanOrEqualExpression(left, right));
}
        |
        "<" right = addExpression()
        {
    left = (ExpressionNode<T, R>) LogicExpressionFactory.toFunction(ComparisonExpressionFactory.lessThanExpression(left, right));
}
        |
        "<=" right = addExpression()
        {
    left = (ExpressionNode<T, R>) LogicExpressionFactory.toFunction(ComparisonExpressionFactory.lessThanOrEqualExpression(left, right));
}
        |
        { u = null; } <LIKE> { stringBuilder.append(" " + token.image + " "); }
        (
            LOOKAHEAD(3)
            <LBRACKET> t = stringLiteral() [ <ESCAPE> { stringBuilder.append(" " + token.image + " "); } u = stringLiteral() ] <RBRACKET>
            |
            t = stringLiteral() [ <ESCAPE> { stringBuilder.append(" " + token.image + " "); } u = stringLiteral() ]
        )
        {
    left = (ExpressionNode<T, R>) LogicExpressionFactory.toFunction(ComparisonExpressionFactory.likeExpression(left, t, u));
}
        |
        LOOKAHEAD(2) { u = null; } <NOT> { stringBuilder.append(" " + token.image + " "); } <LIKE> { stringBuilder.append(" " + token.image + " "); }
        (
            LOOKAHEAD(3)
            <LBRACKET> t = stringLiteral() [ <ESCAPE> { stringBuilder.append(" " + token.image + " "); } u = stringLiteral() ] <RBRACKET>
            |
            t = stringLiteral() [ <ESCAPE> { stringBuilder.append(" " + token.image + " "); } u = stringLiteral() ]
        )
        {
    left = (ExpressionNode<T, R>) LogicExpressionFactory.negate(LogicExpressionFactory.toFunction(ComparisonExpressionFactory.likeExpression(left, t, u)));
}
        |
        LOOKAHEAD(3) <BETWEEN> { stringBuilder.append(" " + token.image + " "); }
        (
            LOOKAHEAD(3)
            <LBRACKET> { stringBuilder.append("("); } low = addExpression() { stringBuilder.append(low.getAlias()); } ( <AND> | <COMMA> ) { stringBuilder.append(" " + token.image + " "); } high = addExpression() <RBRACKET> { stringBuilder.append(")"); }
            |
            low = addExpression() { stringBuilder.append(low.getAlias()); } ( <AND> | <COMMA> ) { stringBuilder.append(" " + token.image + " "); } high = addExpression() { stringBuilder.append(high.getAlias()); }
        )
        {
    left = (ExpressionNode<T, R>) LogicExpressionFactory.toFunction(ComparisonExpressionFactory.betweenExpression(stringBuilder.toString(), left, low, high));
}
        |
        LOOKAHEAD(2) <NOT> { stringBuilder.append(" " + token.image + " "); } <BETWEEN> { stringBuilder.append(" " + token.image + " "); }
            (
                LOOKAHEAD(3)
                <LBRACKET> low = addExpression() { stringBuilder.append(low.getAlias()); } ( <AND> | <COMMA> ) { stringBuilder.append(" " + token.image + " "); } high = addExpression() { stringBuilder.append(high.getAlias()); } <RBRACKET>
                |
                low = addExpression() { stringBuilder.append(low.getAlias()); } ( <AND> | <COMMA> ) { stringBuilder.append(" " + token.image + " "); } high = addExpression() { stringBuilder.append(high.getAlias()); }
            )
        {
            left = (ExpressionNode<T, R>) LogicExpressionFactory.negate(LogicExpressionFactory.toFunction(ComparisonExpressionFactory.betweenExpression(stringBuilder.toString(), left, low, high)));
        }
        |
        LOOKAHEAD(3) <IN> { stringBuilder.append(" " + token.image + " "); }
        <LBRACKET> { stringBuilder.append("("); } right = orExpression() { list = new ArrayList<>(); list.add( right ); }
        ( <COMMA> { stringBuilder.append(", "); } right = orExpression() { list.add( right ); } )* <RBRACKET>
        {
    stringBuilder.append(")");
    left = (ExpressionNode<T, R>) LogicExpressionFactory.toFunction(ComparisonExpressionFactory.inExpression(left, list));
}
        |
        LOOKAHEAD(3) <IN> { stringBuilder.append(" " + token.image + " "); }
        <LBRACKET> { stringBuilder.append("("); } right = select() <RBRACKET>
        {
    stringBuilder.append(")");
    left = (ExpressionNode<T, R>) ComparisonExpressionFactory.inExpression(left, (SelectExpression) right);
}
        |
        LOOKAHEAD(6) <NOT> <IN> <LBRACKET> right = orExpression() { list = new ArrayList<>(); list.add( right ); }
        ( <COMMA> right = orExpression() { list.add( right ); } )* <RBRACKET>
        {
            stringBuilder.append(")");
            left = (ExpressionNode<T, R>) LogicExpressionFactory.negate(LogicExpressionFactory.toFunction(ComparisonExpressionFactory.inExpression(left, list)));
        }
        |
        LOOKAHEAD(6) <NOT> <IN> <LBRACKET> right = select()  <RBRACKET>
        {
            stringBuilder.append(")");
            left = (ExpressionNode<T, R>) LogicExpressionFactory.negate(LogicExpressionFactory.toFunction(ComparisonExpressionFactory.inExpression(left, (SelectExpression) right)));
        }
    )*
    {
        return left;
    }
}

ExpressionNode<T, R> addExpression() :
{
    ExpressionNode<T, R> left;
    ExpressionNode<T, R> right;
    StringBuilder stringBuilder = new StringBuilder();
}
{
    left = multExpr() { stringBuilder.append(left.getAlias()); }
    (
	    LOOKAHEAD( ("+"|"-") multExpr())
	    (
	        "+" { stringBuilder.append("+"); } right = multExpr()
	        {
                stringBuilder.append(right.getAlias());
	            left = ArithmeticExpressionFactory.plus(stringBuilder.toString(), left, right);
	        }
	        |
	        "-" { stringBuilder.append("-"); } right = multExpr()
	        {
                stringBuilder.append(right.getAlias());
	            left = ArithmeticExpressionFactory.minus(stringBuilder.toString(), left, right);
	        }
        )
    )*
    {
        return left;
    }
}

ExpressionNode<T, R> multExpr() :
{
    ExpressionNode<T, R> left;
    ExpressionNode<T, R> right;
    StringBuilder stringBuilder = new StringBuilder();
}
{
    left = unaryExpr() { stringBuilder.append(left.getAlias()); }
    (
        LOOKAHEAD (2)
        <ASTERIX> { stringBuilder.append("*"); } right = unaryExpr()
        {
            stringBuilder.append(right.getAlias());
	        left = ArithmeticExpressionFactory.multiply(stringBuilder.toString(), left, right);
        }
        |
        "/" { stringBuilder.append("/"); } right = unaryExpr()
        {
            stringBuilder.append(right.getAlias());
	        left = ArithmeticExpressionFactory.divide(stringBuilder.toString(), left, right);
        }
        |
        "%" { stringBuilder.append("%"); } right = unaryExpr()
        {
            stringBuilder.append(right.getAlias());
	        left = ArithmeticExpressionFactory.mod(stringBuilder.toString(), left, right);
        }
    )*
    {
        return left;
    }
}

ExpressionNode<T, R> unaryExpr() :
{
    String s = null;
    ExpressionNode<T, R> left = null;
}
{
    (
        "+" left = unaryExpr() { left.setAlias("+" + left.getAlias()); }
        |
        "-" left = unaryExpr()
        {
            left.setAlias("-" + left.getAlias());
            left = UnaryExpressionFactory.negate(left);
        }
        |
        <NOT> left = unaryExpr()
        {
            left = (ExpressionNode<T, R>) LogicExpressionFactory.negate(left);
        }
        |
        left = primaryExpr()
    )
    {
        return left;
    }
}

ExpressionNode<T, R> primaryExpr() :
{
    ExpressionNode<T, R> left = null;
}
{
    (
        left = functionExpression()
        |
        left = literal()
        |
        left = chainedVariable()
        |
        left = caseExpression()
        |
        LOOKAHEAD(2) <LBRACKET> left = orExpression() <RBRACKET> { left.setAlias("(" + left.getAlias() + ")"); }
        |
        LOOKAHEAD(2) <LBRACKET> left = select() <RBRACKET> { left.setAlias("(" + left.getAlias() + ")"); }
    )
    {
        return left;
    }
}

ExpressionNode<T, R> caseExpression() :
{
 ExpressionNode<T, R> expression;
 List<ExpressionNode<T, R>> conditions = new ArrayList<>();
 List<ExpressionNode<T, R>> outcomes = new ArrayList<>();
}
{
    <CASE>
        ( <WHEN> expression = orExpression() { conditions.add(expression); } <THEN> expression = orExpression() { outcomes.add(expression); } )+
        <ELSE> expression = orExpression() { outcomes.add(expression); }
    <END>

    {
        return ConditionalExpressionFactory.caseExpression(conditions, outcomes);
    }
}

ExpressionNode<T, R> literal() :
{
    Token t;
    String s;
    ExpressionNode<T, ?> left = null;
}
{
    (
        (
            s = stringLiteral()
            {
                left = LiteralExpressionFactory.string(s);
            }
        )
        |
        (
            t = <DECIMAL_LITERAL>
            {
	            left = LiteralExpressionFactory.fromDecimal(t.image);
            }
        )
        |
        (
            t = <HEX_LITERAL>
            {
                left = LiteralExpressionFactory.fromHex(t.image);
            }
        )
        |
        (
            t = <OCTAL_LITERAL>
            {
                left = LiteralExpressionFactory.fromOctal(t.image);
            }
        )
        |
        (
            t = <FLOATING_POINT_LITERAL>
            {
            	left = LiteralExpressionFactory.fromDouble(t.image);
            }
        )
        |
        (
            <TRUE>
            {
                left = LiteralExpressionFactory.createTrue();
            }
        )
        |
        (
            <FALSE>
            {
                left = LiteralExpressionFactory.createFalse();
            }
        )
        |
        (
            <NULL>
            {
                left = LiteralExpressionFactory.createNull();
            }
        )
    )
    {
        return (ExpressionNode<T, R>) left;
    }
}

String stringLiteral() :
{
    Token t;
}
{
    t = <STRING_LITERAL>
    {
    	return decode(t.image);
    }
}

ExpressionNode<T, R> chainedVariable() :
{
    ExpressionNode<T, R> variable;
    List<ExpressionNode<R, ?>> args = new ArrayList<>();
    ExpressionNode<T, R> expr;
    StringBuilder builder = new StringBuilder();
}
{
    LOOKAHEAD(2)
    variable = variable() ( "." { builder.append("."); }  expr = variable() { builder.append(expr.getAlias()); args.add((ExpressionNode<R, ?>) expr); } )*
    {
        return AccessorExpressionFactory.chained(builder.toString(), variable, args);
    }
    |
    variable = variable()
    {
        return variable;
    }
}

ExpressionNode<T, R> variable() :
{
    String s;
    Token t;
    ExpressionNode<T, R> right;
    StringBuilder builder = new StringBuilder();
}
{
    LOOKAHEAD(2)
    s = identifier() { builder.append(s); }
    "[" { builder.append("["); }
    right = addExpression() { builder.append(right.getAlias()); }
    "]" { builder.append("]"); }
    {
        return AccessorExpressionFactory.collection(builder.toString(), s, right);
    }
    |
    s = identifier()
    {
        return AccessorExpressionFactory.delegating(s, s);
    }
}

ExpressionNode<T, R> functionExpression() :
{
    String s = null;
    Token t = null;
    List<ExpressionNode<T, ?>> args = new ArrayList<>();
    ExpressionNode<T, R> expr;
    StringBuilder builder = new StringBuilder();
}
{
    (
        expr = functionPosition() { return expr; }
        |
        expr = functionDateAdd() { return expr; }
        |
        expr = functionDateDiff() { return expr; }
        |
        expr = functionExtract() { return expr; }
        |
        t = <FUNCTIONNAME> { builder.append(token.image); }
        ( <DISTINCT> { builder.append(token.image).append(" "); args.add(LiteralExpressionFactory.string("distinct")); } )?
        ( expr = addExpression() { builder.append(expr.getAlias()); args.add(expr); }
        ( <COMMA> { builder.append(", "); } expr = addExpression() { builder.append(expr.getAlias()); args.add(expr); } )* )?
        <RBRACKET>  { builder.append(")"); }
    )
    {
        String functionName = t.image.substring(0, t.image.length() - 1);
        return FunctionExpressionFactory.createFunction(builder.toString(), functionName, args);
    }
}

ExpressionNode<T, R> functionDateAdd() :
{
    Token t;
    ExpressionNode<T, R> expr;
    List<ExpressionNode<T, ?>> args = new ArrayList<>();
    StringBuilder builder = new StringBuilder();
}
{
    t = <DATEADD> { builder.append(token.image); }
    <LBRACKET> { builder.append("("); }
    (
        expr = datePart() { builder.append(token.image); args.add(expr); }
        <COMMA> { builder.append(", "); }
        expr = addExpression() { builder.append(expr.getAlias()); args.add(expr); }
        <COMMA> { builder.append(", "); }
        expr = addExpression() { builder.append(expr.getAlias()); args.add(expr); }
        (
          <COMMA> { builder.append(", "); }
          expr = addExpression() { builder.append(expr.getAlias()); args.add(expr); }
        )*
    )?
    <RBRACKET> { builder.append(")"); }
    {
        String functionName = t.image;
        return FunctionExpressionFactory.createFunction(builder.toString(), functionName, args);
    }
}

ExpressionNode<T, R> functionDateDiff() :
{
    Token t;
    ExpressionNode<T, R> expr;
    List<ExpressionNode<T, ?>> args = new ArrayList<>();
    StringBuilder builder = new StringBuilder();
}
{
    t = <DATEDIFF> { builder.append(token.image); }
    <LBRACKET> { builder.append("("); }
    (
        expr = datePart() { builder.append(token.image); args.add(expr); }
        <COMMA> { builder.append(", "); }
        expr = addExpression() { builder.append(expr.getAlias()); args.add(expr); }
        <COMMA> { builder.append(", "); }
        expr = addExpression() { builder.append(expr.getAlias()); args.add(expr); }
        (
          <COMMA> { builder.append(", "); }
          expr = addExpression() { builder.append(expr.getAlias()); args.add(expr); }
        )*
    )?
    <RBRACKET> { builder.append(")"); }
    {
        String functionName = t.image;
        return FunctionExpressionFactory.createFunction(builder.toString(), functionName, args);
    }
}

ExpressionNode<T, R> functionExtract() :
{
    Token t;
    ExpressionNode<T, R> expr;
    List<ExpressionNode<T, ?>> args = new ArrayList<>();
    StringBuilder builder = new StringBuilder();
}
{
    t = <EXTRACT> { builder.append(token.image); }
    <LBRACKET> { builder.append("("); }
    (
        expr = datePart() { builder.append(token.image); args.add(expr); }
        <FROM> { builder.append(" " + token.image + " "); }
        expr = addExpression() { builder.append(expr.getAlias()); args.add(expr); }
    )?
    <RBRACKET> { builder.append(")"); }
    {
        String functionName = t.image;
        return FunctionExpressionFactory.createFunction(builder.toString(), functionName, args);
    }
}

ExpressionNode<T, R> datePart() :
{
    Token t;
}
{
    ( t = <YEAR> { return (ExpressionNode<T, R>) ConstantExpression.of(ChronoUnit.YEARS); })
    |
    ( t = <MONTH> { return (ExpressionNode<T, R>) ConstantExpression.of(ChronoUnit.MONTHS); })
    |
    ( t = <WEEK> { return (ExpressionNode<T, R>) ConstantExpression.of(ChronoUnit.WEEKS); })
    |
    ( t = <DAY> { return (ExpressionNode<T, R>) ConstantExpression.of(ChronoUnit.DAYS); })
    |
    ( t = <HOUR> { return (ExpressionNode<T, R>) ConstantExpression.of(ChronoUnit.HOURS); })
    |
    ( t = <MINUTE> { return (ExpressionNode<T, R>) ConstantExpression.of(ChronoUnit.MINUTES); })
    |
    t = <SECOND> { return (ExpressionNode<T, R>) ConstantExpression.of(ChronoUnit.SECONDS); }
    |
    t = <MILLISECOND> { return (ExpressionNode<T, R>) ConstantExpression.of(ChronoUnit.MILLIS); }
    |
    {
        throw QueryParsingException.of(Errors.FUNCTION.DATEPART_NOT_SUPPORTED);
    }
}

ExpressionNode<T, R> functionPosition() :
{
    Token t;
    ExpressionNode<T, R> expr;
    List<ExpressionNode<T, ?>> args = new ArrayList<>();
    StringBuilder builder = new StringBuilder();
}
{
    t = <POSITION> { builder.append(token.image); } <LBRACKET> { builder.append("("); } ( expr = addExpression()
    { builder.append(expr.getAlias()); args.add(expr); } )?
    ( LOOKAHEAD(2) ( <IN> { builder.append(" " + token.image + " "); } | <COMMA> { builder.append(token.image); } ) expr = addExpression()
    { builder.append(expr.getAlias()); args.add(expr); } ) ?
    ( <COMMA> { builder.append(","); } expr = addExpression() { builder.append(expr.getAlias()); args.add(expr); } )*
    <RBRACKET> { builder.append(")"); }
    {
        String functionName = t.image;
        return FunctionExpressionFactory.createFunction(builder.toString(), functionName, args);
    }
}

String identifier() :
{
    Token t;
    StringBuilder rc = new StringBuilder();
    String s;
}
{
    (
        t = <ID>
        {
            s = t.image;
        }
        |
        t = <QUOTED_ID>
        {
            s = decode(t.image);
        }
        |
        t = <ASTERIX>
        {
            s = t.image;
        }
    )
    {
        return s;
    }
}