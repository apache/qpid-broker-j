/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY

 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

 //
 // Original File from r450141 of the Apache ActiveMQ project <http://www.activemq.org/site/home.html>
 //

// ----------------------------------------------------------------------------
// OPTIONS
// ----------------------------------------------------------------------------
options {
  STATIC = false;
  UNICODE_INPUT = true;

  // some performance optimizations
  ERROR_REPORTING = false;
}

// ----------------------------------------------------------------------------
// PARSER
// ----------------------------------------------------------------------------

PARSER_BEGIN(ConfiguredObjectFilterParser)
/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

package org.apache.qpid.server.management.plugin.servlet.query;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Collections;

import org.apache.qpid.server.filter.ArithmeticExpression;
import org.apache.qpid.server.filter.BooleanExpression;
import org.apache.qpid.server.filter.ComparisonExpression;
import org.apache.qpid.server.filter.ConstantExpression;
import org.apache.qpid.server.filter.Expression;
import org.apache.qpid.server.filter.OrderByExpression;
import org.apache.qpid.server.filter.LogicExpression;
import org.apache.qpid.server.filter.UnaryExpression;
import org.apache.qpid.server.filter.NamedExpression;

import org.apache.qpid.server.model.ConfiguredObject;

/**
 * JMS Selector Parser generated by JavaCC
 *
 * Do not edit this .java file directly - it is autogenerated from ConfiguredObjectFilterParser.jj
 */
public class ConfiguredObjectFilterParser<E extends ConfiguredObject<?>>
{
    private ConfiguredObjectExpressionFactory _factory;

    public ConfiguredObjectFilterParser()
    {
        this(new StringReader(""));
    }

    public void setConfiguredObjectExpressionFactory(ConfiguredObjectExpressionFactory factory)
    {
        _factory = factory;
    }

    public BooleanExpression<E> parseWhere(String sql) throws ParseException
    {
        this.ReInit(new StringReader(sql));

        return filter();

    }


    public List<Map<String,Expression>> parseSelect(String sql) throws ParseException
    {
        this.ReInit(new StringReader(sql));

        return selectClause();

    }

    public List<OrderByExpression<E>> parseOrderBy(String sql) throws ParseException
    {
        this.ReInit(new StringReader(sql));

        return orderByClause();
    }

    private BooleanExpression<E> asBooleanExpression(Expression<E> value) throws ParseException
    {
        if (value instanceof BooleanExpression)
        {
            return (BooleanExpression<E>) value;
        }
        if (value instanceof ConfiguredObjectExpression)
        {
            return UnaryExpression.createBooleanCast(value);
        }
        throw new ParseException("Expression will not result in a boolean value: " + value);
    }


}

PARSER_END(ConfiguredObjectFilterParser)

// ----------------------------------------------------------------------------
// Tokens
// ----------------------------------------------------------------------------

/* White Space */
SPECIAL_TOKEN :
{
  " " | "\t" | "\n" | "\r" | "\f"
}

/* Comments */
SKIP:
{
  <LINE_COMMENT: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}

SKIP:
{
  <BLOCK_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

/* Reserved Words */
TOKEN [IGNORE_CASE] :
{
    <  NOT     : "NOT">
  | <  AND     : "AND">
  | <  OR      : "OR">
  | <  BETWEEN : "BETWEEN">
  | <  LIKE    : "LIKE">
  | <  ESCAPE  : "ESCAPE">
  | <  IN      : "IN">
  | <  IS      : "IS">
  | <  TRUE    : "TRUE" >
  | <  FALSE   : "FALSE" >
  | <  NULL    : "NULL" >
  | <  AS      : "AS">
  | <  ASC     : "ASC">
  | <  DESC    : "DESC">

}

/* Literals */
TOKEN [IGNORE_CASE] :
{

    < DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* (["l","L"])? >
  | < HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
  | < OCTAL_LITERAL: "0" (["0"-"7"])* >
  | < FLOATING_POINT_LITERAL:
          (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? // matches: 5.5 or 5. or 5.5E10 or 5.E10
        | "." (["0"-"9"])+ (<EXPONENT>)?              // matches: .5 or .5E10
        | (["0"-"9"])+ <EXPONENT>                     // matches: 5E10
    >
  | < #EXPONENT: "E" (["+","-"])? (["0"-"9"])+ >
  | < STRING_LITERAL: "'" ( ("''") | ~["'"] )*  "'" >
  | < FUNCTIONNAME : ["a"-"z", "_", "A"-"Z"] (["a"-"z","A"-"Z", "0"-"9","_"])* "(" >
}

TOKEN [IGNORE_CASE] :
{
    < ID : ["a"-"z", "_", "$"] (["a"-"z","0"-"9","_", "$"])* >
    | < QUOTED_ID : "\"" ( ("\"\"") | ~["\""] )*  "\""  >
}

// ----------------------------------------------------------------------------
// Grammar
// ----------------------------------------------------------------------------
BooleanExpression<E> filter() :
{
    Expression<E> left=null;
}
{
    (
        left = orExpression()
    ) <EOF>
    {
        return asBooleanExpression(left);
    }

}

Expression<E> orExpression() :
{
    Expression<E> left;
    Expression<E> right;
}
{
    (
        left = andExpression()
        (
            <OR> right = andExpression()
            {
                left = LogicExpression.createOR(asBooleanExpression(left), asBooleanExpression(right));
            }
        )*
    )
    {
        return left;
    }

}


Expression<E> andExpression() :
{
    Expression<E> left;
    Expression<E> right;
}
{
    (
        left = equalityExpression()
        (
            <AND> right = equalityExpression()
            {
                left = LogicExpression.createAND(asBooleanExpression(left), asBooleanExpression(right));
            }
        )*
    )
    {
        return left;
    }
}

Expression<E> equalityExpression() :
{
    Expression<E> left;
    Expression<E> right;
}
{
    (
        left = comparisonExpression()
        (

            "=" right = comparisonExpression()
            {
                left = ComparisonExpression.createEqual(left, right);
            }
            |
            "<>" right = comparisonExpression()
            {
                left = ComparisonExpression.createNotEqual(left, right);
            }
            |
            LOOKAHEAD(2)
            <IS> <NULL>
            {
                left = ComparisonExpression.createIsNull(left);
            }
            |
            <IS> <NOT> <NULL>
            {
                left = ComparisonExpression.createIsNotNull(left);
            }
        )*
    )
    {
        return left;
    }
}

Expression<E> comparisonExpression() :
{
    Expression<E> left;
    Expression<E> right;
    Expression<E> low;
    Expression<E> high;
    String t, u;
	boolean not;
	ArrayList<Expression> list;
}
{
    (
        left = addExpression()
        (

                ">" right = addExpression()
                {
                    left = ComparisonExpression.createGreaterThan(left, right);
                }
            |
                ">=" right = addExpression()
                {
                    left = ComparisonExpression.createGreaterThanEqual(left, right);
                }
            |
                "<" right = addExpression()
                {
                    left = ComparisonExpression.createLessThan(left, right);
                }
            |
                "<=" right = addExpression()
                {
                    left = ComparisonExpression.createLessThanEqual(left, right);
                }
           |
				{
					u=null;
				}
		        <LIKE> t = stringLiteral()
		        	[ <ESCAPE> u = stringLiteral() ]
		        {
                    left = ComparisonExpression.createLike(left, t, u);
		        }
           |
	        	LOOKAHEAD(2)
				{
					u=null;
				}
		        <NOT> <LIKE> t = stringLiteral() [ <ESCAPE> u = stringLiteral() ]
		        {
                    left = ComparisonExpression.createNotLike(left, t, u);
		        }
            |
		        <BETWEEN> low = addExpression() <AND> high = addExpression()
		        {
					left = ComparisonExpression.createBetween(left, low, high);
		        }
	        |
	        	LOOKAHEAD(2)
		        <NOT> <BETWEEN> low = addExpression() <AND> high = addExpression()
		        {
					left = ComparisonExpression.createNotBetween(left, low, high);
		        }
            |
				<IN>
		        "("
		            right = primaryExpr()
		            {
			            list = new ArrayList<>();
			            list.add( right );
		            }
			        (
			        	","
			            right = primaryExpr()
			            {
				            list.add( right );
			            }

			        )*
		        ")"
		        {
		           left = ComparisonExpression.createInFilter(left, list, true );
		        }
            |
	        	LOOKAHEAD(2)
	            <NOT> <IN>
		        "("
		            right = primaryExpr()
		            {
			            list = new ArrayList<>();
			            list.add( right );
		            }
			        (
			        	","
			            right = primaryExpr()
			            {
				            list.add( right );
			            }

			        )*
		        ")"
		        {
		           left = ComparisonExpression.createNotInFilter(left, list, true);
		        }

        )*
    )
    {
        return left;
    }
}

Expression<E> addExpression() :
{
    Expression<E> left;
    Expression<E> right;
}
{
    left = multExpr()
    (
	    LOOKAHEAD( ("+"|"-") multExpr())
	    (
	        "+" right = multExpr()
	        {
	            left = ArithmeticExpression.createPlus(left, right);
	        }
	        |
	        "-" right = multExpr()
	        {
	            left = ArithmeticExpression.createMinus(left, right);
	        }
        )

    )*
    {
        return left;
    }
}

Expression<E> multExpr() :
{
    Expression<E> left;
    Expression<E> right;
}
{
    left = unaryExpr()
    (
        "*" right = unaryExpr()
        {
	        left = ArithmeticExpression.createMultiply(left, right);
        }
        |
        "/" right = unaryExpr()
        {
	        left = ArithmeticExpression.createDivide(left, right);
        }
        |
        "%" right = unaryExpr()
        {
	        left = ArithmeticExpression.createMod(left, right);
        }

    )*
    {
        return left;
    }
}


Expression<E> unaryExpr() :
{
    String s=null;
    Expression<E> left=null;
}
{
	(
		LOOKAHEAD( "+" unaryExpr() )
	    "+" left=unaryExpr()
	    |
	    "-" left=unaryExpr()
	    {
	        left = UnaryExpression.createNegate(left);
	    }
	    |
	    <NOT> left=unaryExpr()
	    {
		    left = UnaryExpression.createNOT( asBooleanExpression(left) );
	    }
	    |
	    left = primaryExpr()
    )
    {
        return left;
    }

}

Expression<E> primaryExpr() :
{
    Expression<E> left=null;
}
{
    (
        left = functionExpression()
        |
        left = literal()
        |
        left = variable()
        |
        "(" left = orExpression() ")"
        )

    {
        return left;
    }
}



ConstantExpression<E> literal() :
{
    Token t;
    String s;
    ConstantExpression<E> left=null;
}
{
    (
        (
            s = stringLiteral()
            {
                left = new ConstantExpression<>(s);
            }
        )
        |
        (
            t = <DECIMAL_LITERAL>
            {
            	left = ConstantExpression.createFromDecimal(t.image);
            }
        )
        |
        (
            t = <HEX_LITERAL>
            {
            	left = ConstantExpression.createFromHex(t.image);
            }
        )
        |
        (
            t = <OCTAL_LITERAL>
            {
            	left = ConstantExpression.createFromOctal(t.image);
            }
        )
        |
        (
            t = <FLOATING_POINT_LITERAL>
            {
            	left = ConstantExpression.createFloat(t.image);
            }
        )
        |
        (
            <TRUE>
            {
                left = ConstantExpression.TRUE;
            }
        )
        |
        (
            <FALSE>
            {
                left = ConstantExpression.FALSE;
            }
        )
        |
        (
            <NULL>
            {
                left = ConstantExpression.NULL;
            }
        )
    )
    {
        return left;
    }
}

String stringLiteral() :
{
    Token t;
    StringBuffer rc = new StringBuffer();
    boolean first=true;
}
{
    t = <STRING_LITERAL>
    {
    	// Decode the sting value.
    	String image = t.image;
    	for( int i=1; i < image.length()-1; i++ ) {
            char c = image.charAt(i);
            if( c == (char) 0x27 )//single quote
            {
                i++;
            }
            rc.append(c);
    	}
	    return rc.toString();
    }
}

ConfiguredObjectExpression variable() :
{
    String s;
    Token t;
    ConfiguredObjectExpression right;
}
{
    LOOKAHEAD(2)
    (
        s = identifier() "."  right = variable()
    )
    {
        return _factory.createConfiguredObjectExpression( s, right );
    }
    |
    LOOKAHEAD(2)
    (
        s = identifier() "[" t = <DECIMAL_LITERAL> "]"
    )
    {
        return _factory.createConfiguredObjectExpression( s, Integer.valueOf( t.image ) );
    }
    |
    (
        s = identifier()
    )
    {
        return _factory.createConfiguredObjectExpression( s );
    }

}

Expression<E> functionExpression() :
{
    String s;
    Token t;
    List<Expression> args = new ArrayList<>();
    Expression<E> expr;
}
{
    (
        t = <FUNCTIONNAME> ( expr = addExpression() { args.add(expr); } ( "," expr = addExpression() { args.add(expr); } )* )? ")"
    )
    {
        return _factory.createFunctionExpression( t.image.substring(0, t.image.length() - 1), args );
    }
}

String identifier() :
{
    Token t;
    StringBuffer rc = new StringBuffer();
    String s;
}
{
    (
        t = <ID>
        {
            s = t.image;
        }
        |
        t = <QUOTED_ID>
        {
            // Decode the sting value.
            String image = t.image;
            for( int i=1; i < image.length()-1; i++ ) {
                char c = image.charAt(i);
                if( c == '"' )
                {
                    i++;
                }
                rc.append(c);
            }
            s = rc.toString();
        }


    )
    {
        return s;
    }
}

List<Map<String, Expression>> selectClause() :
{
    List<Map<String, Expression>> returnVal = new ArrayList<>();
    Map<String, Expression> element;
}
{
    ( element = selectClauseElement() { returnVal.add( element ); }
    ) ( "," element = selectClauseElement() { returnVal.add( element ); } )*  <EOF>
    {
        return returnVal;
    }
}

Map<String, Expression> selectClauseElement() :
{
    String name = null;
    Expression<E> expr;

}
{
    ( expr = addExpression() ( <AS> name = identifier() )?
      {
          if(name == null)
          {
              name = ( expr instanceof NamedExpression ) ?  ((NamedExpression) expr).getName() : "";
          }
          return Collections.singletonMap( name, expr );
      }
    )
}

List<OrderByExpression<E>> orderByClause() :
{
    List<OrderByExpression<E>> returnVal = new ArrayList<>();
    OrderByExpression<E> element;
}
{
    ( element = orderByClauseElement() { returnVal.add( element ); }
    ) ( "," element = orderByClauseElement() { returnVal.add( element ); } )*  <EOF>
    {
        return returnVal;
    }
}

OrderByExpression<E> orderByClauseElement() :
{
    Expression<E> expr;
    OrderByExpression<E> orderByExpr;
    OrderByExpression.Order order = OrderByExpression.Order.ASC;
}
{
    ( expr = addExpression() ( <ASC> | <DESC> { order = OrderByExpression.Order.DESC; } )?
      {
          return new OrderByExpression<>(expr, order);
      }
    )
}
